import ColorMixin from '../../../../services/color-config/ColorMixin';
declare class SelectOptionListProps {
    options: import("vue-class-component").WithDefault<any[]>;
    noOptionsText: import("vue-class-component").WithDefault<string>;
    getSelectedState: import("vue-class-component").WithDefault<Function>;
    getText: Function | undefined;
    getTrackBy: Function | undefined;
    multiple: import("vue-class-component").WithDefault<boolean>;
    search: import("vue-class-component").WithDefault<string>;
    hoveredOption: import("vue-class-component").WithDefault<string | object>;
    tabindex: import("vue-class-component").WithDefault<number>;
}
declare const VaSelectOptionList_base: import("vue-class-component").VueConstructor<ColorMixin & {
    $: import("vue").ComponentInternalInstance;
    $data: {};
    $props: Partial<{}> & Omit<import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, never>;
    $attrs: {
        [x: string]: unknown;
    };
    $refs: {
        [x: string]: unknown;
    };
    $slots: Readonly<{
        [name: string]: import("vue").Slot | undefined;
    }>;
    $root: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>> | null;
    $parent: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>> | null;
    $emit: (event: string, ...args: any[]) => void;
    $el: any;
    $options: import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>;
    $forceUpdate: import("vue").ReactiveEffect<any>;
    $nextTick: typeof import("vue").nextTick;
    $watch(source: string | Function, cb: Function, options?: import("vue").WatchOptions<boolean> | undefined): import("vue").WatchStopHandle;
} & import("vue").ShallowUnwrapRef<{}> & {} & {} & import("vue").ComponentCustomProperties & import("vue-class-component").ClassComponentHooks & {
    $: import("vue").ComponentInternalInstance;
    $data: {};
    $props: Partial<import("vue-class-component").ExtractDefaultProps<SelectOptionListProps>> & Omit<import("vue-class-component").ExtractProps<SelectOptionListProps> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, import("vue-class-component").DefaultKeys<SelectOptionListProps>>;
    $attrs: {
        [x: string]: unknown;
    };
    $refs: {
        [x: string]: unknown;
    };
    $slots: Readonly<{
        [name: string]: import("vue").Slot | undefined;
    }>;
    $root: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>> | null;
    $parent: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>> | null;
    $emit: (event: string, ...args: any[]) => void;
    $el: any;
    $options: import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>;
    $forceUpdate: import("vue").ReactiveEffect<any>;
    $nextTick: typeof import("vue").nextTick;
    $watch(source: string | Function, cb: Function, options?: import("vue").WatchOptions<boolean> | undefined): import("vue").WatchStopHandle;
} & import("vue-class-component").ExtractProps<SelectOptionListProps>>;
export default class VaSelectOptionList extends VaSelectOptionList_base {
    itemRefs: Record<number, any>;
    created(): void;
    beforeUpdate(): void;
    setItemRef(option: number): (el: any) => void;
    get hoveredOptionComputed(): any;
    set hoveredOptionComputed(value: any);
    get filteredOptions(): never[];
    selectOption(option: any): void;
    getOptionClass(option: any): {
        'va-select-option-list__option': boolean;
        'va-select-option-list__option--selected': any;
    };
    getOptionStyle(option: any): {
        color: string;
        backgroundColor: string;
    };
    isHovered(option: any): boolean;
    updateHoveredOption(option: string[] | string): void;
    hoverPreviousOption(): void;
    hoverNextOption(): void;
    hoverFirstOption(): void;
    scrollToOption(option: any): void;
    focus(): void;
}
export {};
